/**
 * Returns a singleton
 *
 * @module urlsign
*/

var url = require('url');
require("google-closure-library");
goog.require('goog.crypt.Hmac');
goog.require('goog.crypt.Sha1');
goog.require('goog.crypt.base64');

 module.exports = exports = {
   _latitude: "",
   _longitude: "",
   _zoom: "",
   _size: "",
   _maptype: "",
   _markerColor: "",
   _client: "",
   _privateKey: "",

   /**
   * Initialize the urlsign singleton with a privateKey and other options
   *
   *
   * @param {Object} options              The options object
   * @param {String} options.latitude     The latitude coordinate to use for generating the url
   * @param {String} options.longitude    The longitude coordinate to use for generating the url
   * @param {String} options.zoom         The zoom level to use for generating the url
   * @param {String} options.size         The map size to use for generating the url
   * @param {String} options.maptype      The map type to use for generating the url
   * @param {String} options.markerColor  The marker color to use for generating the url
   * @param {String} options.client       The client ID to use for generating the url
   * @param {String} options.privateKey   The private key to hash the URLs with
   */

   init: function(options) {
     this._latitude = options.latitude;
     this._longitude = options.longitude;
     this._zoom = options.zoom;
     this._size = options.size;
     this._maptype = options.maptype;
     this._markerColor = options.markerColor;
     this._client = options.client;
     this._privateKey = options.privateKey;
   },

   getBaseUrl: function() {
     if (!this._latitude.length || !this._longitude.length || !this._zoom.length || !this._size.length || !this._maptype.length || !this._markerColor.length || !this._client.length) {
       throw new Error("One or more parameters are missing!");
     }
     return "https://maps.googleapis.com/maps/api/staticmap?center="
                + this._latitude
                + ","
                + this._longitude
                + "&zoom="
                + this._zoom
                + "&size="
                + this._size
                + "&maptype="
                + this._maptype
                + "&markers=color:"
                + this._markerColor
                + "|"
                + this._latitude
                + ","
                + this._longitude
                + "&client="
                + this._client;
   },

   getUrlToSign: function(baseUrl) {
     var parsedUrl = url.parse(inputUrl, true);
     return parsedUrl.path;
   },

   getDecodedKey: function() {
     if (!this._privateKey.length) {
       throw new Error("Call init() with privateKey first");
     }
     try {
        return goog.crypt.stringToByteArray(
            goog.crypt.base64.decodeString(this._privateKey, true));
      } catch (e) {
        return 'Invalid character in Private Key';
      }
   },
   /**
   * Sign a given URL and return the signature
   *
   * @param  {String} urlToSign URL to sign
   * @throws {Error}            If init() is not called first with a privateKey
   * @return {String}           URL signature
   */
  getUrlSignature: function(decodedKey, urlToSign) {
    if (!this._privateKey.length) {
      throw new Error("Call init() with privateKey first");
    }
    // Create a signature using the private key and the URL-encoded
    // String using HMAC SHA1. This signature will be binary.
    var hmac = new goog.crypt.Hmac(new goog.crypt.Sha1(), decodedSecret, 64);
    var signature = hmac.getHmac(urlToSign);
    // Encode the binary signature into base64 for use within a URL.
    return encodedSignature = goog.crypt.base64.encodeString(
        goog.crypt.byteArrayToString(signature), false);
  },
  /**
  * Check that the signature does not contain a plus sign. If it does,
  * replace it with a minus sign.
  *
  * NOTE: In the future we may need to expand this to other special characters
  * or we may discover that we don't need it after all and that Anne just made
  * a stupid mistake. Hey, it happens!
  *
  * @param  {String} encodedSignature The encoded signature generated by getUrlSignature()
  * @throws {Error}                   If init() is not called first with a privateKey
  * @return {String}                  Modified signature (only if it contains a plus sign)
  */
  checkSignature: function (encodedSignature) {
    try {
      encodedSignature = encodedSignature.replace(/\+/g, "-");
      return encodedSignature;
    } catch (e) {
      return 'Error using regular expression.';
    }
  },
  /**
  * Generate a url to sign; decode private key, encode signature, check signature,
  * and generate signed url.
  *
  * @return {String}           Signed Google Static Maps URL
  */
  getSignedUrl: function() {
    var baseUrl = this.getBaseUrl(this._latitude, this._longitude, this._zoom, this._size, this._maptype, this._client);
    var urlToSign = this.getUrlToSign(baseUrl);
    var decodedKey = this.getDecodedKey(this._privateKey);
    var encodedSignature = this.getUrlSignature(decodedKey, urlToSign);
    var encodedSignature = this.checkSignature(encodedSignature);
    return baseUrl + "&signature=" + encodedSignature;
  }
};
